use std::env;
use std::fs;
use std::path::{Path, PathBuf};

use serde_json::Value;

fn main() {
    let manifest_dir =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR should be set"));
    let themes_dir = manifest_dir.join("assets/themes");

    println!("cargo:rerun-if-changed={}", themes_dir.display());

    let mut theme_files: Vec<PathBuf> = Vec::new();
    if let Ok(entries) = fs::read_dir(&themes_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if is_json_file(&path) {
                println!("cargo:rerun-if-changed={}", path.display());
                theme_files.push(path);
            }
        }
    }

    theme_files.sort();
    let mut seen_ids: Vec<String> = Vec::new();

    let mut generated = String::from("// @generated by build.rs\n");
    generated.push_str("const BUILTIN_THEMES: &[(&str, &str)] = &[\n");

    for path in theme_files {
        let Some(id) = path.file_stem().and_then(|stem| stem.to_str()) else {
            continue;
        };

        validate_theme_json(&path);
        ensure_unique_theme_id(&mut seen_ids, id);

        let relative = match path.strip_prefix(&manifest_dir) {
            Ok(relative) => relative,
            Err(_) => continue,
        };

        let relative_unix = relative.to_string_lossy().replace('\\', "/");
        generated.push_str(&format!(
            "    ({id:?}, include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/{relative_unix}\"))),\n"
        ));
    }

    generated.push_str("];\n");

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR should be set"));
    let output = out_dir.join("builtin_themes.rs");
    fs::write(output, generated).expect("failed to write generated builtin theme list");
}

fn validate_theme_json(path: &Path) {
    let raw = fs::read_to_string(path).unwrap_or_else(|error| {
        panic!("failed to read built-in theme {}: {error}", path.display())
    });

    serde_json::from_str::<Value>(&raw).unwrap_or_else(|error| {
        panic!("invalid built-in theme json in {}: {error}", path.display())
    });
}

fn ensure_unique_theme_id(seen: &mut Vec<String>, id: &str) {
    let normalized = id.to_ascii_lowercase();
    if seen.iter().any(|existing| existing == &normalized) {
        panic!("duplicate built-in theme id detected: {id}");
    }

    seen.push(normalized);
}

fn is_json_file(path: &Path) -> bool {
    path.extension()
        .and_then(|ext| ext.to_str())
        .is_some_and(|ext| ext.eq_ignore_ascii_case("json"))
}
